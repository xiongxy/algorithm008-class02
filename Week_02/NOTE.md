一步一步补全它吧。
# 数据结构及算法(神器：https://visualgo.net/)

## 数据结构

### 一维结构

- Stack栈

	- 定义：先入后出
	- 插入和删除时间复杂度均为O(1)
	- 查询为O(n)，没有顺序可言

- Queue队列

	- 定义：先入先出
	- 插入和删除时间复杂度均为O(1)
	- 查询为O(n)，没有顺序可言

- Deque(Double-End Queue) 双端队列

	- Stack和Queue的结合体，可以在最前端进行pop,push 也可以在最末端进行pop,push
	- 插入和删除时间复杂度均为O(1)
	- 查询为O(n)，没有顺序可言

- Priority Queue 优先队列

	- 插入O(1)
	- 取出操作O(logN)  按照元素的优先级取出
	- 定义：按照优先级取出
	- 底层实现的数据结构较为多样和复杂: heap、 bst(binary search tree)、treap
	- 源代码实现。

- Array 数组

	- 插入删除为O(n)
	- 查询为O(n)
	- 访问为O(1)

- LinkinList 链表

	- 插入删除为O(1)
	- 查询访问为O(n)

- Skip List 跳表

	- 插入删除访问搜索均为O(logN)

- Hash table 哈希表

	- 概念

		- 定义：也叫做散列表，是根据关键码值(Key)而直接进行访问的数据结构。
它通过把关键码值映射到表中的一个位置来访问记录，加快查询速度，
这个映射函数叫做散列函数(Hah Function)，存放记录的数组我们叫做哈希表。
		- 两个不同的数据根据哈希函数生成了同样的码值，这个叫做Hash碰撞。

			- 解决方法1：拉链式解决冲突法
增加一个维度链表， 依次放入。

		- 插入删除查询都是O(1)

	- 衍生出的高级结构

		- Hash Map 

			- Key-value 对，key值不重复

		- Hash Set

			- 不重复元素的集合

### 二维结构

- Tree 树

	- 定义：有一个根节点Root，左子树，右子树
	- 遍历

		- 前序遍历

			- 根-左-右

		- 中序遍历

			- 左-根-右

		- 后序遍历

			- 左-右-根

	- 衍生树

		- 二叉树(Binary Tree)

			- 定义：儿子节点只有两个

		- 二叉树搜索树(Binary Search Tree)

			- 定义：是指一颗空树或者具有下列性质的二叉树

				- 1.左子树上的所有节点的值均小于它的根节点的值
				- 2.右子树上的所有节点的值均大于它的根节点的值
				- 3.以此类推，左、右子树也分别为二叉搜索树
				- 中序遍历也称为升序遍历

			- 插入删除查询 时间复杂度都为O(logN)

		- 完全二叉树

			- 定义：除了最下面的叶子节点，其他节点都是满状态(左子树或者右子树都是存在的)

- Heap 堆

	- 定义：它是一个抽象的数据结构，可以迅速找到一堆树中的最大或者最小值的数据结构。
将根节点最大的堆叫做大顶堆或大根堆，
根节点最小的叫做小顶堆或小根堆
常见的实现堆有二叉堆、斐波那契堆等
	- 实现

		- 二叉堆

			- 通过完全二叉树来实现
二叉堆(大顶)它满足以下性质：
1. 是一颗完全树
2. 树种的任意节点的值总是>=其子节点的值
			- 实现细节

				- 1. 二叉堆一般使用"数组"来实现
				- 2.假设第一个元素在数组中的索引为0的话：
(1) 索引为I的左孩子的索引是(2*i+1)
(2) 索引为I的右孩子的索引是(2*i+2)
(3) 索引为I的父节点的索引是 floor((i-1)/2)
				- 子主题 3

			- insert 插入操作

				- 1. 新元素直接放到尾部
				- 2.将元素挪移到相应的位置，依次向上调整整个堆的结构（一直调整到根）
				- Heapifyup 函数 向上调整

					- 与父亲节点比较，如果大于父亲节点则替换

				- 时间复杂度为0(logN)

			- delete 删除操作

				- 1. 堆尾元素替换到顶部（即对顶替代删除掉）
				- 2. 依次从根部向下调整整个堆的结构(一直到堆尾)
				- HeapifyDown 函数 向下调整

					- 1.替换到顶部的元素去比较左右儿子谁大
					- 2.于最大的儿子进行替换

## 算法

### 347.前K个高频元素

- 解法1：HashMap + 桶排

	- 1. 遍历整个数组存放在hash中(值为key，次数为value)
	- 2.遍历hash存放在 list[] 中(次数为下标，list存放数值)
	- 3.逆向遍历list[]

- 解放2：HashMap+最小堆

	- 1. 遍历整个数组存放在hash中(值为key，次数为value)
	- 2.遍历map，使用最小堆频率最大的K个元素
	- 3.取出最小堆中元素

### 49.丑数

- 解法1:动态规划

	- 1.已知第一个丑数为1，根据丑数的概念得知，后续丑数都为前丑数*2|3|5
	- 2. 维护三个Index 分别代表 丑数*2  丑数*3  丑数*5
	- 3.找到当前计算最小的丑数,放入数组中
	- 4.当前计算最小丑数会等于 丑数*2 |  丑数*3 | 丑数*5 , 把相应的Index更新，这样你会一直求出最小的丑数并按顺序放入数组中。
	- 5. 返回数组中前N-1个丑数 

*XMind: ZEN - Trial Version*